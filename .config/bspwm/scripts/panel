#!/bin/sh

# Load panel configuration
. "$BSPWM_CONFIG/panel.cfg"

# Set PATH for scripts
PATH="${HOME}/bin:$PATH"

# Kill any previous running instance
pname=$(basename "$0")
if [ "$(pgrep -cx "$pname")" -gt 1 ] ; then
	printf "%s\n" "The panel is already running." >&2
	pkill -x "$pname"
fi

trap 'trap - TERM; kill 0' INT TERM QUIT EXIT

bspc config top_padding $(($(bspc config top_padding) + BARHEIGHT + EDGEWIDTH))

# Function to cut long lines
cut() {
	local newstr
	local curstr="$1" || return 1
	local maxlength=${2-80}
	local symbol="..."
	local length=$((maxlength - ${#symbol}))
	if [ "${#curstr}" -gt "$maxlength" ]; then
		newstr="$(printf '%s' "$curstr" | \
		    awk -v l=$length \
		    '{ string=substr($0, 1, l); print string; }')${symbol}"
	else
		newstr="$curstr"
	fi
	printf "%s" "$newstr"
}

# Function to get all the information
getInfo() {
	# WM desktop information
	while true; do
		# Interval between checks in seconds
		wait=0.1
		# Create line
		wm_line="W"
		# Get monitors
		cur_monitor=$(xrandr --current | awk '/ primary/ {print $1}') \
		    && wm_line="${wm_line}M${cur_monitor}"
		monitor_names=$(xrandr --current | awk '/ connected/ {printf "%s ", $1}')
		# Get current desktop and number of desktops
		cur_desktop=$(xdotool get_desktop)
		num_desktops=$(xdotool get_num_desktops)
		# Assign desktop names to positional arguments
		desktop_names=$(xprop -root '\t$0+' _NET_DESKTOP_NAMES \
		    | awk -F'\t' '{print $2}' | sed 's/[",]//g') \
		    && set -- $desktop_names
		# Get active windows IDs
		win_ids=$(xprop -root '\t$0+' _NET_CLIENT_LIST \
		    | awk -F'\t' '{print $2}' | sed 's/[",]//g')
		# Add desktops before the current one
		for desktop in $(seq 0 $((cur_desktop - 1))); do
			# Reset switches
			occupied=0
			urgent=0
			# Get desktop name
			desktop_name="$1" && { [ $# -ne 0 ] && shift; }
			# Check whether any window belongs to this desktop
			for id in $win_ids; do
				win_desktop=$(xdotool get_desktop_for_window "$id" 2>/dev/null) || continue
				if [ "$win_desktop" -eq "$desktop" ]; then
					# Set occupied switch
					occupied=1
					# Check if urgent bit is set
					xprop -id "$id" WM_HINTS | grep -q 'The urgency hint bit is set' && urgent=1
				fi
			done
			# Add desktop to line
			if [ "$urgent" -eq 1 ]; then
				wm_line="${wm_line}:u$((desktop+1))_${desktop_name}"
			elif [ "$occupied" -eq 1 ]; then
				wm_line="${wm_line}:o$((desktop+1))_${desktop_name}"
			fi
		done
		# Add current desktop
		wm_line="${wm_line}:O$((cur_desktop+1))_${1}" && { [ $# -ne 0 ] && shift; }
		# Add desktops after the current one
		for desktop in $(seq $((cur_desktop + 1)) $num_desktops); do
			# Reset switches
			occupied=0
			urgent=0
			# Get desktop name
			desktop_name="$1" && { [ $# -ne 0 ] && shift; }
			# Check whether any window belongs to this desktop
			for id in $win_ids; do
				win_desktop=$(xdotool get_desktop_for_window "$id" 2>/dev/null) || continue
				if [ "$win_desktop" -eq "$desktop" ]; then
					# Set occupied switch
					occupied=1
					# Check if urgent bit is set
					xprop -id "$id" WM_HINTS | grep -q 'The urgency hint bit is set' && urgent=1
				fi
			done
			# Add desktop to line
			if [ "$urgent" -eq 1 ]; then
				wm_line="${wm_line}:u$((desktop+1))_${desktop_name}"
			elif [ "$occupied" -eq 1 ]; then
				wm_line="${wm_line}:o$((desktop+1))_${desktop_name}"
			fi
		done

		# Dump information to file
		printf '%s\n' "$wm_line"

		# Wait before repeating
		sleep $wait
	done &

	# Active window information
	while true; do
		# Interval between checks in seconds
		wait=0.1
		# Create line
		title_line="TTL"
		# Get title and cut long lines
		win_title="$(xdotool getactivewindow getwindowname 2>/dev/null)" \
		    && title_line="${title_line} $(cut "$win_title" 120)"

		# Dump information to file
		printf '%s\n' "$title_line"

		# Wait before repeating
		sleep $wait
	done &

	# System information
	while true; do
		# Interval between checks in seconds
		wait=0.2
		# Create line
		sys_line="SYS"
		# cpu information
		cpu_info=$(getCPU.sh -e %) \
		    && sys_line="${sys_line} %{A:urxvtc -name popup -g $TERM_BIG -e htop --sort-key PERCENT_cpu:}%{F$COLOR_FREE_FG}cpu%{F-} ${cpu_info}%{A}"
		# Memory information
		mem_info=$(getMem.sh -e %) \
		    && sys_line="${sys_line} %{A:urxvtc -name popup -g $TERM_BIG -e htop --sort-key PERCENT_MEM:}%{F$COLOR_FREE_FG}ram%{F-} ${mem_info}%{A}"

		# Dump information to file
		printf '%s\n' "$sys_line"

		# Wait before repeating
		sleep $wait
	done &

	# Network information
	while true; do
		# Interval between checks in seconds
		wait=0.2
		# Create line
		net_line="NET"
		# Network information
		net_info=$(getNetwork.sh) \
		    && net_line="${net_line} %{A:urxvtc -name popup -g $TERM_SMALL -e bash -c \"/sbin/ifconfig 2>/dev/null && read -rsp 'Press any key to continue...' -n 1 key\":}%{F$COLOR_FREE_FG}net%{F-} ${net_info}%{A}"

		# Dump information to file
		printf '%s\n' "$net_line"

		# Wait before repeating
		sleep $wait
	done &

	# Power information
	while true; do
		# Interval between checks in seconds
		wait=0.2
		# Create line
		pwr_line="PWR"
		# Power information
		bat_info=$(getBattery.sh -e %) \
		    && pwr_line="${pwr_line} %{F$COLOR_FREE_FG}bat%{F-} ${bat_info}"

		# Dump information to file
		printf '%s\n' "$pwr_line"

		# Wait before repeating
		sleep $wait
	done &

	# Volume information
	while true; do
		# Interval between checks in seconds
		wait=0.2
		# Create line
		vol_line="VOL"
		# Volume information
		vol_info=$(getVolume.sh -e % Master) \
		    && vol_line="${vol_line} %{A1:urxvtc -name popup -g $TERM_SMALL -e alsamixer:}%{A2:amixer -q sset Master toggle:}%{A4:amixer -q sset Master 2%+:}%{A5:amixer -q sset Master 2%-:}%{F$COLOR_FREE_FG}vol%{F-} ${vol_info}%{A}%{A}%{A}%{A}"

		# Dump information to file
		printf '%s\n' "$vol_line"

		# Wait before repeating
		sleep $wait
	done &

	# Date information
	while true; do
		# Interval between checks in seconds
		wait=0.2
		# Create line
		clk_line="CLK"
		# Date information
		date_info=$(getDate.sh) \
		    && clk_line="${clk_line} %{F$COLOR_FREE_FG}clk%{F-} $date_info "

		# Dump information to file
		printf '%s\n' "$clk_line"

		# Wait before repeating
		sleep $wait
	done &

	# Keyboard information
	while true; do
		# Interval between checks in seconds
		wait=1
		# Create line
		kbd_line="KBD"
		# Keyboard information
		kbd_info=$(mngKbd.sh -g) \
		    && kbd_line="${kbd_line} %{A1:mngKbd.sh -p:}%{A2:mngKbd.sh:}%{F$COLOR_FREE_FG}kbd%{F-} $kbd_info%{A}%{A}"

		# Dump information to file
		printf '%s\n' "$kbd_line"

		# Wait before repeating
		sleep $wait
	done &

	# Music Player Daemon information
	while true; do
		# Interval between checks in seconds
		wait=1
		# Create line
		mpd_line="MPD"
		# Get MPD information and cut long lines
		HOST="${MPDHOST-localhost}"
		mpd_info=$(getSong.sh "$HOST") \
		    && mpd_line="${mpd_line} %{A1:urxvtc -name popup -g $TERM_SMALL -e ncmpcpp -h $HOST:}%{A2:mpc -h $HOST toggle:}%{A4:mpc -h $HOST prev:}%{A5:mpc -h $HOST next:}%{F$COLOR_FREE_FG}mpd%{F-} $(cut "$mpd_info" 75)%{A}%{A}%{A}%{A}"

		# Dump information to file
		printf '%s\n' "$mpd_line"

		# Wait before repeating
		sleep $wait
	done &

	# OpenWeatherMap information
	while true; do
		# Interval between checks in seconds
		wait=300
		# Create line
		owm_line="OWM"
		# Temperature information
		temp_info=$(getWeather.sh) \
		    && owm_line="${owm_line} %{A:urxvtc -name popup -g $TERM_BIG -e lynx http\://wttr.in/:}%{F$COLOR_FREE_FG}tem%{F-} ${temp_info}%{A}"

		# Dump information to file
		printf '%s\n' "$owm_line"

		# Wait before repeating
		sleep $wait
	done &

	# ToDo information
	while true; do
		# Interval between checks in seconds
		wait=0.2
		# Create line
		tsk_line="TSK"
		# ToDo information
		tasks_info=$(getTasks.sh) \
		    && tsk_line="${tsk_line} %{A:gvim -o ~/todo.txt ~/done.txt:}%{F$COLOR_FREE_FG}tsk%{F-} ${tasks_info}%{A}"

		# Dump information to file
		printf '%s\n' "$tsk_line"

		# Wait before repeating
		sleep $wait
	done &

	# Mail information
	while true; do
		# Interval between checks in seconds
		wait=30
		# Create line
		msg_line="MSG"
		# Mail messages
		msg_info=$(getMail.sh) \
		    && msg_line="${msg_line} %{A:urxvtc -name popup -g $TERM_BIG -e env LANG=en_US.UTF-8 mutt:}%{F$COLOR_FREE_FG}msg%{F-} $msg_info%{A}"

		# Dump information to file
		printf '%s\n' "$msg_line"

		# Wait before repeating
		sleep $wait
	done &
}

# Get number of monitors
num_mon=$(bspc query -M | wc -l)

# Parse information
getInfo | while read -r line; do
	case $line in
		SYS*)
			# system info output
			sys_info="%{F$COLOR_STATUS_FG}%{B$COLOR_STATUS_BG}${line#???}%{B-}%{F-}"
			;;
		NET*)
			# netowrk info output
			net_info="%{F$COLOR_STATUS_FG}%{B$COLOR_STATUS_BG}${line#???}%{B-}%{F-}"
			;;
		PWR*)
			# power info output
			pwr_info="%{F$COLOR_STATUS_FG}%{B$COLOR_STATUS_BG}${line#???}%{B-}%{F-}"
			;;
		CLK*)
			# date info output
			clk_info="%{F$COLOR_STATUS_FG}%{B$COLOR_STATUS_BG}${line#???}%{B-}%{F-}"
			;;
		VOL*)
			# volume info output
			vol_info="%{F$COLOR_STATUS_FG}%{B$COLOR_STATUS_BG}${line#???}%{B-}%{F-}"
			;;
		KBD*)
			# kbd info output
			kbd_info="%{F$COLOR_STATUS_FG}%{B$COLOR_STATUS_BG}${line#???}%{B-}%{F-}"
			;;
		MPD*)
			# mpd info output
			mpd_info="%{F$COLOR_STATUS_FG}%{B$COLOR_STATUS_BG}${line#???}%{B-}%{F-}"
			;;
		OWM*)
			# weather info output
			owm_info="%{F$COLOR_STATUS_FG}%{B$COLOR_STATUS_BG}${line#???}%{B-}%{F-}"
			;;
		TSK*)
			# todo info output
			tsk_info="%{F$COLOR_STATUS_FG}%{B$COLOR_STATUS_BG}${line#???}%{B-}%{F-}"
			;;
		MSG*)
			# mail info output
			msg_info="%{F$COLOR_STATUS_FG}%{B$COLOR_STATUS_BG}${line#???}%{B-}%{F-}"
			;;
		TTL*)
			# title output
			title="%{F$COLOR_TITLE_FG}%{B$COLOR_TITLE_BG}${line#???} %{B-}%{F-}"
			;;
		W*)
			# bspwm internal state
			wm_infos=""
			IFS=':'
			set -- ${line#?}
			while [ "$#" -gt 0 ] ; do
				item=$1
				id=${item#?}
				num=${id%_*}
				name=${id#*_}
				case $item in
					M*)
						# active monitor
						if [ "$num_mon" -gt 1 ] ; then
							wm_infos="$wm_infos %{F$COLOR_ACTIVE_MONITOR_FG}%{B$COLOR_ACTIVE_MONITOR_BG}%{A4:bspc monitor --focus prev.occupied:}%{A5:bspc monitor --focus next.occupied:} ${name} %{A}%{A}%{B-}%{F-}  "
						fi
						;;
					m*)
						# inactive monitor
						if [ "$num_mon" -gt 1 ] ; then
							wm_infos="$wm_infos
							%{F$COLOR_INACTIVE_MONITOR_FG}%{B$COLOR_INACTIVE_MONITOR_BG}%{A:bspc monitor --focus ${name}:}%{A4:bspc monitor --focus prev.occupied:}%{A5:bspc monitor --focus next.occupied:} ${name} %{A}%{A}%{A}%{B-}%{F-}  "
						fi
						;;
					O*)
						# focused occupied desktop
						wm_infos="${wm_infos}%{F$COLOR_FOCUSED_OCCUPIED_FG}%{B$COLOR_FOCUSED_OCCUPIED_BG}%{U$COLOR_UNDERLINE}%{+u}%{A4:xdotool key super+Left:}%{A5:xdotool key super+Right:} ${name} %{A}%{A}%{-u}%{B-}%{F-}"
						;;
					F*)
						# focused free desktop
						wm_infos="${wm_infos}%{F$COLOR_FOCUSED_FREE_FG}%{B$COLOR_FOCUSED_FREE_BG}%{U$COLOR_UNDERLINE}%{+u}%{A4:xdotool key super+Left:}%{A5:xdotool key super+Right:} ${name} %{A}%{A}%{-u}%{B-}%{F-}"
						;;
					U*)
						# focused urgent desktop
						wm_infos="${wm_infos}%{F$COLOR_FOCUSED_URGENT_FG}%{B$COLOR_FOCUSED_URGENT_BG}%{U$COLOR_UNDERLINE}%{+u}%{A4:xdotool key super+Left:}%{A5:xdotool key super+Right:} ${name} %{A}%{A}%{-u}%{B-}%{F-}"
						;;
					o*)
						# occupied desktop
						wm_infos="${wm_infos}%{F$COLOR_OCCUPIED_FG}%{B$COLOR_OCCUPIED_BG}%{A1:xdotool key super+${num}:}%{A4:xdotool key super+Left:}%{A5:xdotool key super+Right:} ${name} %{A}%{A}%{A}%{B-}%{F-}"
						;;
					u*)
						# urgent desktop
						wm_infos="${wm_infos}%{F$COLOR_URGENT_FG}%{B$COLOR_URGENT_BG}%{A1:xdotool key super+${num}:}%{A4:xdotool key super+Left:}%{A5:xdotool key super+Right:} ${name} %{A}%{A}%{A}%{B-}%{F-}"
						;;
				esac
				shift
			done
			;;
	esac
	printf "%s\n" "%{l}${title}%{r}${mpd_info}${kbd_info}${vol_info}${pwr_info}${clk_info}%{c}${wm_infos}"
done

exit
# vim: set ts=8 sw=8 tw=0 noet :
